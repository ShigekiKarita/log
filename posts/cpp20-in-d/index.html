<!doctype html><html class=no-js lang=jp><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>C++17以降の機能をD言語で - log</title><script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script><meta name=description content><meta property="og:title" content="C++17以降の機能をD言語で"><meta property="og:description" content="default 三方演算子 (three-way operator) https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html C++20の auto operator<=>() = default; を模倣しました。D言語だと opCmp が三方演算子に相当します。Dには tupleof があるので構造体の要素を再帰的に辿って比"><meta property="og:type" content="article"><meta property="og:url" content="https://shigekikarita.github.io/log/posts/cpp20-in-d/"><meta property="article:published_time" content="2020-09-04T10:06:03+09:00"><meta property="article:modified_time" content="2020-09-04T10:06:03+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++17以降の機能をD言語で"><meta name=twitter:description content="default 三方演算子 (three-way operator) https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html C++20の auto operator<=>() = default; を模倣しました。D言語だと opCmp が三方演算子に相当します。Dには tupleof があるので構造体の要素を再帰的に辿って比"><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/log/css/style.css><link rel=stylesheet href=/log/css/custom.css><link rel="shortcut icon" href=/log/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-139201189-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class=body><div class="container container--outer"><header class=header><div class=container><div class=logo><a class=logo__link href=/log/ title=log rel=home><div class=logo__title>log</div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=https://shigekikarita.github.io>home</a></li><li class=menu__item><a class=menu__link href=https://github.com/ShigekiKarita/log>github</a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>C++17以降の機能をD言語で</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-09-04T10:06:03>2020-09-04</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/log/categories/d rel=category>D</a></span></div></div></header><div class="content post__content clearfix"><h2 id=default-三方演算子-three-way-operator>default 三方演算子 (three-way operator)</h2><p><a href=https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html>https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html</a></p><p>C++20の <code>auto operator&lt;=>() = default;</code> を模倣しました。D言語だと <code>opCmp</code> が三方演算子に相当します。Dには tupleof があるので構造体の要素を再帰的に辿って比較続けることは容易です。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d><span style=color:#75715e>/// C++20 like default opCmp implementation
</span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>defaultOpCmp</span><span style=color:#f92672>(</span>T<span style=color:#f92672>)(</span>T a<span style=color:#f92672>,</span> T b<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>if</span> <span style=color:#f92672>(</span>__traits<span style=color:#f92672>(</span>compiles<span style=color:#f92672>,</span> a<span style=color:#f92672>.</span><span style=color:#a6e22e>opCmp</span><span style=color:#f92672>(</span>b<span style=color:#f92672>)))</span> <span style=color:#66d9ef>return</span> a<span style=color:#f92672>.</span><span style=color:#a6e22e>opCmp</span><span style=color:#f92672>(</span>b<span style=color:#f92672>);</span>
  <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>if</span> <span style=color:#f92672>(</span>__traits<span style=color:#f92672>(</span>compiles<span style=color:#f92672>,</span> a<span style=color:#f92672>.</span><span style=color:#a6e22e>tupleof</span><span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>int</span> c<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>foreach</span> <span style=color:#f92672>(</span>i<span style=color:#f92672>,</span> x<span style=color:#f92672>;</span> a<span style=color:#f92672>.</span><span style=color:#a6e22e>tupleof</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
      c <span style=color:#f92672>=</span> defaultOpCmp<span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> b<span style=color:#f92672>.</span><span style=color:#a6e22e>tupleof</span><span style=color:#f92672>[</span>i<span style=color:#f92672>]);</span>
      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> c<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>return</span> c<span style=color:#f92672>;</span>
  <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> <span style=color:#f92672>(</span>a <span style=color:#f92672>&lt;</span> b<span style=color:#f92672>)</span> <span style=color:#f92672>?</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#f92672>(</span>a <span style=color:#f92672>&gt;</span> b<span style=color:#f92672>)</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e>/// Usage of defaultOpCmp
</span><span style=color:#75715e></span><span style=color:#66d9ef>version</span> <span style=color:#f92672>(</span>unittest<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>A</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>opCmp</span><span style=color:#f92672>(</span>A that<span style=color:#f92672>)</span> <span style=color:#66d9ef>const</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span> <span style=color:#f92672>}</span> <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>B</span> <span style=color:#f92672>{}</span>
  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>S</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>int</span> i<span style=color:#f92672>;</span> <span style=color:#66d9ef>double</span> d<span style=color:#f92672>;</span> A a<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>alias</span> opCmp <span style=color:#f92672>=</span> defaultOpCmp<span style=color:#f92672>;</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
unittest <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>assert</span><span style=color:#f92672>(</span>S<span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> S<span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>));</span>
  <span style=color:#66d9ef>assert</span><span style=color:#f92672>(</span>S<span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>)</span> <span style=color:#f92672>&lt;</span> S<span style=color:#f92672>(</span><span style=color:#ae81ff>3</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>4</span><span style=color:#f92672>));</span>
  <span style=color:#66d9ef>assert</span><span style=color:#f92672>(</span>S<span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>)</span> <span style=color:#f92672>&lt;</span> S<span style=color:#f92672>(</span><span style=color:#ae81ff>3</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>));</span>
<span style=color:#f92672>}</span>
</code></pre></div><h2 id=構造化束縛>構造化束縛</h2><p><a href=https://cpprefjp.github.io/lang/cpp17/structured_bindings.html>https://cpprefjp.github.io/lang/cpp17/structured_bindings.html</a></p><p>C++17の機能で一番良いなぁと思ってるのがこの機能です。D言語では with 文で <code>foo.bar</code> のような識別子に <code>with (foo) { bar; }</code> としてアクセスできること、 <code>tuple!("foo", "bar")(1, 2)</code> のようにタプルのフィールド名を指定できることを組み合わせると、変数のように束縛できます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d><span style=color:#f92672>import</span> std.meta <span style=color:#f92672>:</span> aliasSeqOf<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> std.typecons <span style=color:#f92672>:</span> isTuple<span style=color:#f92672>,</span> tuple<span style=color:#f92672>,</span> Tuple<span style=color:#f92672>;</span>

<span style=color:#75715e>/// Flatten nested tuple (a, (b, c)) to (a, b, c).
</span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>flatten</span><span style=color:#f92672>(</span>Ts <span style=color:#f92672>...)(</span>Ts ts<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>if</span> <span style=color:#f92672>(</span>isTuple<span style=color:#f92672>!(</span>Ts<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]))</span>
    <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>if</span> <span style=color:#f92672>(</span>ts<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> flatten<span style=color:#f92672>(</span>ts<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>].</span><span style=color:#a6e22e>expand</span><span style=color:#f92672>);</span>
    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> tuple<span style=color:#f92672>(</span>flatten<span style=color:#f92672>(</span>ts<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>].</span><span style=color:#a6e22e>expand</span><span style=color:#f92672>).</span><span style=color:#a6e22e>expand</span><span style=color:#f92672>,</span>
                      flatten<span style=color:#f92672>(</span>ts<span style=color:#f92672>[</span><span style=color:#ae81ff>1.</span><span style=color:#f92672>.</span><span style=color:#a6e22e>$</span><span style=color:#f92672>]).</span><span style=color:#a6e22e>expand</span><span style=color:#f92672>);</span>
  <span style=color:#66d9ef>else</span>
    <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>if</span> <span style=color:#f92672>(</span>ts<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> tuple<span style=color:#f92672>(</span>ts<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]);</span>
    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> tuple<span style=color:#f92672>(</span>ts<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>],</span> flatten<span style=color:#f92672>(</span>ts<span style=color:#f92672>[</span><span style=color:#ae81ff>1.</span><span style=color:#f92672>.</span><span style=color:#a6e22e>$</span><span style=color:#f92672>]).</span><span style=color:#a6e22e>expand</span><span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e>/// Flatten and rename tuple fields to given names.
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#a6e22e>bind</span><span style=color:#f92672>(</span>names<span style=color:#f92672>...)</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>auto</span> <span style=color:#a6e22e>bind</span><span style=color:#f92672>(</span>T<span style=color:#f92672>)(</span>T t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> tuple<span style=color:#f92672>!(</span>aliasSeqOf<span style=color:#f92672>!(</span>flatten<span style=color:#f92672>(</span>tuple<span style=color:#f92672>(</span>names<span style=color:#f92672>))))(</span>flatten<span style=color:#f92672>(</span>t<span style=color:#f92672>).</span><span style=color:#a6e22e>expand</span><span style=color:#f92672>);</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e>/// Usage of bind
</span><span style=color:#75715e></span>unittest <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>auto</span> t <span style=color:#f92672>=</span> tuple<span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> tuple<span style=color:#f92672>(</span><span style=color:#ae81ff>2.3</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;foo&#34;</span><span style=color:#f92672>));</span>
  <span style=color:#66d9ef>with</span> <span style=color:#f92672>(</span>t<span style=color:#f92672>.</span><span style=color:#a6e22e>bind</span><span style=color:#f92672>!(</span><span style=color:#e6db74>&#34;x&#34;</span><span style=color:#f92672>,</span> tuple<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;y&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;z&#34;</span><span style=color:#f92672>)))</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>assert</span><span style=color:#f92672>(</span>x <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>);</span>
    <span style=color:#66d9ef>assert</span><span style=color:#f92672>(</span>y <span style=color:#f92672>==</span> <span style=color:#ae81ff>2.3</span><span style=color:#f92672>);</span>
    <span style=color:#66d9ef>assert</span><span style=color:#f92672>(</span>z <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;foo&#34;</span><span style=color:#f92672>);</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h2 id=パターンマッチ>パターンマッチ?</h2><p>複数の型に対する overload をまとめて書きたい動機があり、 C++では <a href=https://cpprefjp.github.io/reference/variant/visit.html>std::visit</a> があります。D言語の std.variant では <a href=https://dlang.org/phobos/std_variant.html#.visit>visit</a>, 継承関係のクラス群には <a href=https://dlang.org/phobos/std_algorithm_comparison.html#.castSwitch>std.algorithm.castSwitch</a> がありました。ついでに tuple に対するやつは標準にないので <a href=https://github.com/ShigekiKarita/tupleops>tupleops.overload</a> というやつを昔作りました。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-d data-lang=d><span style=color:#f92672>import</span> tupleops<span style=color:#f92672>:</span>

<span style=color:#66d9ef>alias</span> f <span style=color:#f92672>=</span> overload<span style=color:#f92672>!(</span>
  <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i<span style=color:#f92672>)</span> <span style=color:#f92672>=&gt;</span> i<span style=color:#f92672>.</span><span style=color:#a6e22e>to</span><span style=color:#f92672>!</span><span style=color:#66d9ef>string</span><span style=color:#f92672>,</span>
  <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> j<span style=color:#f92672>)</span> <span style=color:#f92672>=&gt;</span> i <span style=color:#f92672>+</span> j<span style=color:#f92672>,</span>
  <span style=color:#f92672>(</span><span style=color:#66d9ef>double</span> d<span style=color:#f92672>)</span> <span style=color:#f92672>=&gt;</span> d <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>);</span>

<span style=color:#66d9ef>auto</span> t <span style=color:#f92672>=</span> tuple<span style=color:#f92672>(</span><span style=color:#ae81ff>1.0</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>,</span> tuple<span style=color:#f92672>(</span><span style=color:#ae81ff>3</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>4</span><span style=color:#f92672>));</span>
<span style=color:#66d9ef>assert</span><span style=color:#f92672>(</span>map<span style=color:#f92672>!</span>f<span style=color:#f92672>(</span>t<span style=color:#f92672>)</span> <span style=color:#f92672>==</span> tuple<span style=color:#f92672>(</span><span style=color:#ae81ff>2.0</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;2&#34;</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>7</span><span style=color:#f92672>));</span>
</code></pre></div><p>さらに C++ では <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1371r2.pdf>inspect</a> という値(と型)に対するパターンマッチが提案されてますが、構文が複雑すぎて入らないと思ってます。私は新しい予約語や構文を追加するよりも、D言語のように switch 文の case を定数式とれるようにするか、連想辞書リテラルを作るほうが良いと思います。個人的には OCaml や Rust のような <a href=https://doc.rust-jp.rs/book/second-edition/ch18-03-pattern-syntax.html>ML 系言語のパターンマッチ</a> が構文的には理想です。</p></div><div class="post__tags tags clearfix"><svg class="tags__icon icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/log/tags/d/ rel=tag>D</a></li></ul></div></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="Shigeki Karita avatar" src=/log/img/avatar.jpg class=avatar height=90 width=90></figure><div class=authorbox__header><span class=authorbox__name>About Shigeki Karita</span></div><div class=authorbox__description>D言語と日々の研究について雑記</div></div><nav class="post-nav flex"><div class="post-nav__item post-nav__item--prev"><a class=post-nav__link href=/log/posts/nas/ rel=prev><span class=post-nav__caption>«&#8201;Previous</span><p class=post-nav__post-title>給付金でNAS組んだ</p></a></div><div class="post-nav__item post-nav__item--next"><a class=post-nav__link href=/log/posts/emacs-dman/ rel=next><span class=post-nav__caption>Next&#8201;»</span><p class=post-nav__post-title>Emacs dynamic moduleでD言語くんを召喚する</p></a></div></nav></div></div><script type=text/x-mathjax-config>
 MathJax.Hub.Config({
     tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
     TeX: { equationNumbers: {autoNumber: "AMS"} }
 });
 MathJax.Hub.Config({
     tex2jax: {
         inlineMath: [['$','$'], ['\\(','\\)']],
         displayMath: [['$$','$$'], ['\[','\]']],
         processEscapes: true,
         processEnvironments: true,
         skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
         TeX: { equationNumbers: { autoNumber: "AMS" },
                extensions: ["AMSmath.js", "AMSsymbols.js"] }
     }
 });

</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-6633457078111023",enable_page_level_ads:true});</script></div><script async defer src=/log/js/menu.js></script></body></html>